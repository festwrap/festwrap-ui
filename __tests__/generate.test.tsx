import {
  describe,
  expect,
  vi,
  it,
  beforeAll,
  afterAll,
  afterEach,
  beforeEach,
} from 'vitest';
import {
  cleanup,
  render,
  screen,
  waitFor,
  within,
} from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import GeneratePlaylistPage, { GenerateProps } from '@/pages/generate';
import { ReactNode } from 'react';
import { ServiceProvider } from '@/contexts/ServiceContext';
import { toast } from 'sonner';

vi.mock('next/image', () => ({
  __esModule: true,
  default: (props: any) => {
    const { src, alt } = props;
    // eslint-disable-next-line @next/next/no-img-element
    return <img src={src} alt={alt} {...props} />;
  },
}));

vi.mock('sonner', () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

const staticTranslations: GenerateProps = {
  translations: {
    meta: {
      title: 'Generate a playlist',
      description: 'Generate a playlist description',
      keywords: 'Generate a playlist keywords',
    },
  },
};

const TEST_DATA = {
  playlists: {
    existing: {
      id: 'existing-playlist-1',
      name: 'My Existing Playlist',
      description: 'Existing playlist description',
      isPublic: true,
    },
    new: {
      name: 'Fest Bops',
      description: 'Generated by FestWrap',
    },
  },
  artists: {
    single: { name: 'Holding Absence', imageUri: null },
    multiple: [
      { name: 'Holding Absence', imageUri: null },
      { name: 'Loathe', imageUri: null },
    ],
  },
  createdPlaylistId: '123',
};

type PlaylistsService = {
  searchPlaylists: ReturnType<typeof vi.fn>;
  createNewPlaylist: ReturnType<typeof vi.fn>;
};

type ArtistsService = {
  searchArtists: ReturnType<typeof vi.fn>;
};

type ServiceMocks = {
  playlistsService: PlaylistsService;
  artistsService: ArtistsService;
};

const createServiceMocks = (): ServiceMocks => ({
  playlistsService: {
    searchPlaylists: vi.fn().mockResolvedValue({
      playlists: [TEST_DATA.playlists.existing],
    }),
    createNewPlaylist: vi.fn().mockResolvedValue({
      playlistCreated: { id: TEST_DATA.createdPlaylistId },
    }),
  },
  artistsService: {
    searchArtists: vi.fn().mockResolvedValue({
      artists: [TEST_DATA.artists.single],
    }),
  },
});

let mockServices: ServiceMocks;
let user: ReturnType<typeof userEvent.setup>;

const renderWithProviders = (
  ui: ReactNode,
  services: ServiceMocks = mockServices
) => {
  return render(<ServiceProvider value={services}>{ui}</ServiceProvider>);
};

const actions = {
  async click(selector: RegExp | string) {
    const element = screen.getByRole('button', { name: selector });
    await user.click(element);
    return element;
  },

  async type(labelText: RegExp | string, value: string) {
    const input = screen.getByLabelText(labelText);
    await user.clear(input);
    await user.type(input, value);
    return input;
  },

  async selectRadio(name: RegExp | string) {
    const radio = screen.getByRole('radio', { name });
    if (!radio.hasAttribute('data-state="checked"')) {
      await user.click(radio);
    }
    return radio;
  },

  async completeFirstStepNewPlaylist(
    playlistName = 'My new playlist',
    description = ''
  ) {
    await actions.selectRadio(/steps.step1.form.createNewPlaylist.title/i);
    await actions.type(
      /steps.step1.form.createNewPlaylist.giveAName/i,
      playlistName
    );

    if (description) {
      await actions.type(
        /steps.step1.form.createNewPlaylist.giveADescription/i,
        description
      );
    }

    await actions.click(/steps.navigation.next/i);
    return actions.waitForStep(/steps.step2.title/i);
  },

  async completeFirstStepExistingPlaylist(
    playlistName = TEST_DATA.playlists.existing.name
  ) {
    await actions.selectRadio(/steps.step1.form.useExistingPlaylist.title/i);
    await actions.selectPlaylist(playlistName);
    await actions.click(/steps.navigation.next/i);
    return actions.waitForStep(/steps.step2.title/i);
  },

  async completeSecondStep(artistNames = [TEST_DATA.artists.single.name]) {
    for (const name of artistNames) {
      await actions.selectArtist(name);
    }
    await actions.click(/steps.navigation.generate/i);
    return actions.waitForStep(/steps.step3.title/i);
  },

  async selectArtist(artistName: string) {
    const searchInput = screen.getByPlaceholderText(
      'steps.step2.searchPlaceholder'
    );
    await user.clear(searchInput);
    await user.type(searchInput, artistName);

    await waitFor(async () => {
      const option = screen.getByRole('option', { name: artistName });
      await user.click(option);
      expect(screen.getByText(artistName)).toBeInTheDocument();
    });
  },

  async selectPlaylist(playlistName: string) {
    const combobox = screen.getByRole('combobox');
    await user.click(combobox);

    const searchInput = screen.getByPlaceholderText(
      /steps.step1.form.useExistingPlaylist.playlistSelector.placeholder/i
    );
    await user.type(searchInput, playlistName);

    await waitFor(async () => {
      const option = screen.getByRole('option', { name: playlistName });
      await user.click(option);
      expect(screen.getByText(playlistName)).toBeInTheDocument();
    });
  },

  async waitForStep(stepTitleRegex: RegExp) {
    return waitFor(() => {
      const stepContent = screen.getByRole('tabpanel');
      expect(within(stepContent).getByText(stepTitleRegex)).toBeInTheDocument();
    });
  },
};

describe('GeneratePlaylistPage', () => {
  beforeAll(() => {
    user = userEvent.setup({ delay: null });
  });

  afterAll(() => {
    vi.restoreAllMocks();
  });

  afterEach(() => {
    cleanup();
    vi.clearAllMocks();
  });

  beforeEach(() => {
    mockServices = createServiceMocks();
  });

  it('should navigate between steps correctly', async () => {
    renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

    await actions.completeFirstStepNewPlaylist();

    await actions.click(/steps.navigation.previous/i);
    await actions.waitForStep(/steps.step1.title/i);
  });

  describe('New Playlist Flow', () => {
    it('should successfully generate a new playlist from start to finish', async () => {
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      const { name, description } = TEST_DATA.playlists.new;
      const artistsToSelect = [TEST_DATA.artists.single.name];

      await actions.completeFirstStepNewPlaylist(name, description);
      await actions.completeSecondStep(artistsToSelect);

      expect(
        screen.getByText(/steps.step3.playlisyGeneratedSuccessfully/i)
      ).toBeInTheDocument();
      const embeddedPlaylist = screen.getByTitle('Spotify embedded playlist');
      expect(embeddedPlaylist).toHaveAttribute(
        'src',
        `https://open.spotify.com/embed/playlist/${TEST_DATA.createdPlaylistId}`
      );

      expect(
        mockServices.playlistsService.createNewPlaylist
      ).toHaveBeenCalledWith({
        playlist: {
          name,
          description,
          isPublic: false,
        },
        artists: artistsToSelect.map((name) => ({ name })),
      });
    });

    it('should handle multiple artist selection and removal', async () => {
      mockServices.artistsService.searchArtists.mockResolvedValue({
        artists: TEST_DATA.artists.multiple,
      });

      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);
      await actions.completeFirstStepNewPlaylist();

      const [artist1, artist2] = TEST_DATA.artists.multiple.map((a) => a.name);
      await actions.selectArtist(artist1);
      await actions.selectArtist(artist2);

      expect(screen.getByText(artist1)).toBeInTheDocument();
      expect(screen.getByText(artist2)).toBeInTheDocument();

      const removeButton = screen.getByLabelText(
        `steps.step2.removeArtist ${artist1}`
      );
      await user.click(removeButton);
      expect(screen.queryByText(artist1)).not.toBeInTheDocument();
      expect(screen.getByText(artist2)).toBeInTheDocument();
    });

    it('should validate playlist name is required', async () => {
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      await actions.selectRadio(/steps.step1.form.createNewPlaylist.title/i);
      await actions.click(/steps.navigation.next/i);

      expect(
        await screen.findByText(/steps.errors.name.required/i)
      ).toBeInTheDocument();
    });

    it('should display error toast when API fails', async () => {
      mockServices.playlistsService.createNewPlaylist.mockRejectedValue(
        new Error('API Error')
      );

      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      await actions.completeFirstStepNewPlaylist();
      await actions.selectArtist(TEST_DATA.artists.single.name);
      await actions.click(/steps.navigation.generate/i);

      await waitFor(() => {
        expect(toast.error).toHaveBeenCalledWith(
          'steps.errors.createNewPlaylist.unexpectedError'
        );
      });
    });
  });

  describe('Existing Playlist Flow', () => {
    it('should successfully update an existing playlist', async () => {
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      await actions.completeFirstStepExistingPlaylist();
      await actions.completeSecondStep([TEST_DATA.artists.single.name]);

      expect(
        screen.getByText(/steps.step3.playlisyGeneratedSuccessfully/i)
      ).toBeInTheDocument();
      const embeddedPlaylist = screen.getByTitle('Spotify embedded playlist');
      expect(embeddedPlaylist).toHaveAttribute(
        'src',
        'https://open.spotify.com/embed/playlist/mock-playlist-id'
      );
    });

    it('should validate playlist selection is required', async () => {
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      await actions.selectRadio(/steps.step1.form.useExistingPlaylist.title/i);
      await actions.click(/steps.navigation.next/i);

      expect(
        await screen.findByText(/steps.errors.playlistSelected.required/i)
      ).toBeInTheDocument();
    });
  });
});
