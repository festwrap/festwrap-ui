import { describe, expect, vi, it, beforeAll, beforeEach } from 'vitest';
import { render, screen, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import GeneratePlaylistPage, { GenerateProps } from '@/pages/generate';
import { ReactNode } from 'react';
import { ServiceProvider } from '@/contexts/ServiceContext';
import { toast } from 'sonner';
import { IPlaylistsService } from '@/services/playlistsService';
import { IArtistsService } from '@/services/artistsService';
import { CreatedPlaylistStatus } from '@/entities/playlists';

vi.mock('next/image', () => ({
  __esModule: true,
  default: (props: any) => {
    const { src, alt } = props;
    // eslint-disable-next-line @next/next/no-img-element
    return <img src={src} alt={alt} {...props} />;
  },
}));

vi.mock('sonner', () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

const staticTranslations: GenerateProps = {
  translations: {
    meta: {
      title: 'Generate a playlist',
      description: 'Generate a playlist description',
      keywords: 'Generate a playlist keywords',
    },
  },
};

const TEST_DATA = {
  playlists: {
    existing: {
      id: 'existing-playlist-1',
      name: 'My Existing Playlist',
      description: 'Existing playlist description',
      isPublic: true,
    },
    new: {
      name: 'Fest Bops',
      description: 'Generated by FestWrap',
    },
  },
  artists: {
    single: { name: 'Holding Absence', imageUri: undefined },
    multiple: [
      { name: 'Holding Absence', imageUri: undefined },
      { name: 'Loathe', imageUri: undefined },
    ],
  },
  createdPlaylistId: '123',
};

type ServiceMocks = {
  playlistsService: IPlaylistsService;
  artistsService: IArtistsService;
};

const createServiceMocks = (): ServiceMocks => ({
  playlistsService: {
    searchPlaylists: vi.fn().mockResolvedValue({
      playlists: [TEST_DATA.playlists.existing],
    }),
    createNewPlaylist: vi.fn().mockResolvedValue({
      playlistCreated: {
        id: TEST_DATA.createdPlaylistId,
        status: CreatedPlaylistStatus.OK,
      },
    }),
    updatePlaylist: vi.fn().mockResolvedValue({
      playlistUpdated: { status: CreatedPlaylistStatus.OK },
    }),
  },
  artistsService: {
    searchArtists: vi.fn().mockResolvedValue({
      artists: [TEST_DATA.artists.single],
    }),
  },
});

let mockServices: ServiceMocks;
let user: ReturnType<typeof userEvent.setup>;

const renderWithProviders = (
  ui: ReactNode,
  services: ServiceMocks = mockServices
) => {
  return render(<ServiceProvider value={services}>{ui}</ServiceProvider>);
};

const actions = {
  async click(selector: RegExp | string) {
    const element = screen.getByRole('button', { name: selector });
    await user.click(element);
  },

  async type(labelText: RegExp | string, value: string) {
    const input = screen.getByLabelText(labelText);
    await user.clear(input);
    await user.type(input, value);
  },

  async selectRadio(name: RegExp | string) {
    const radio = screen.getByRole('radio', { name });
    if (!radio.hasAttribute('data-state="checked"')) {
      await user.click(radio);
    }
  },

  async completeFirstStepNewPlaylist(
    playlistName = 'My new playlist',
    description = ''
  ) {
    await actions.selectRadio(/steps.step1.form.createNewPlaylist.title/i);
    await actions.type(
      /steps.step1.form.createNewPlaylist.giveAName/i,
      playlistName
    );

    if (description) {
      await actions.type(
        /steps.step1.form.createNewPlaylist.giveADescription/i,
        description
      );
    }

    await actions.click(/steps.navigation.next/i);
    await actions.waitForStep(/steps.step2.title/i);
  },

  async completeFirstStepExistingPlaylist(
    playlistName = TEST_DATA.playlists.existing.name
  ) {
    await actions.selectRadio(/steps.step1.form.useExistingPlaylist.title/i);
    await actions.selectPlaylistAndAssetSelected(playlistName);
    await actions.click(/steps.navigation.next/i);
    await actions.waitForStep(/steps.step2.title/i);
  },

  async completeSecondStep(artistNames = [TEST_DATA.artists.single.name]) {
    for (const name of artistNames) {
      await actions.selectArtistAndAssertSelected(name);
    }
    await actions.click(/steps.navigation.generate/i);
    await actions.waitForStep(/steps.step3.title/i);
  },

  async selectArtistAndAssertSelected(artistName: string) {
    const searchInput = screen.getByPlaceholderText(
      'steps.step2.searchPlaceholder'
    );
    await user.clear(searchInput);
    await user.type(searchInput, artistName);

    await waitFor(async () => {
      const option = screen.getByRole('option', { name: artistName });
      await user.click(option);
      expect(screen.getByText(artistName)).toBeInTheDocument();
    });
  },

  async selectPlaylistAndAssetSelected(playlistName: string) {
    const combobox = screen.getByRole('combobox');
    await user.click(combobox);

    const searchInput = screen.getByPlaceholderText(
      /steps.step1.form.useExistingPlaylist.playlistSelector.placeholder/i
    );
    await user.type(searchInput, playlistName);

    await waitFor(async () => {
      const option = screen.getByRole('option', { name: playlistName });
      await user.click(option);
      expect(screen.getByText(playlistName)).toBeInTheDocument();
    });
  },

  async waitForStep(stepTitleRegex: RegExp) {
    return waitFor(() => {
      const stepContent = screen.getByRole('tabpanel');
      const stepTitle = within(stepContent).getByRole('heading', {
        name: stepTitleRegex,
      });
      expect(stepTitle).toBeInTheDocument();
      return stepTitle;
    });
  },
};

describe('GeneratePlaylistPage', () => {
  beforeAll(() => {
    user = userEvent.setup({ delay: null });
  });

  beforeEach(() => {
    mockServices = createServiceMocks();
  });

  it('should navigate to the first step clicking on the previous button', async () => {
    renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

    await actions.completeFirstStepNewPlaylist();

    await actions.click(/steps.navigation.previous/i);

    const firstStepTitle = await actions.waitForStep(/steps.step1.title/i);
    expect(firstStepTitle).toBeInTheDocument();
  });

  it.each([
    {
      scenario: 'existing playlist update',
      getUpdatePlaylistFn: () => mockServices.playlistsService.updatePlaylist,
      firstStepFn: actions.completeFirstStepExistingPlaylist,
    },
    {
      scenario: 'new playlist creation',
      getUpdatePlaylistFn: () =>
        mockServices.playlistsService.createNewPlaylist,
      firstStepFn: actions.completeFirstStepNewPlaylist,
    },
  ])(
    'should display error toast when $scenario API fails',
    async ({ getUpdatePlaylistFn, firstStepFn }) => {
      vi.mocked(getUpdatePlaylistFn()).mockRejectedValue(
        new Error('API Error')
      );
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      await firstStepFn();
      await actions.selectArtistAndAssertSelected(
        TEST_DATA.artists.single.name
      );
      await actions.click(/steps.navigation.generate/i);

      await waitFor(() => {
        expect(toast.error).toHaveBeenCalledWith(
          'steps.errors.submitPlaylist.unexpectedError'
        );
      });
    }
  );

  describe('New Playlist Flow', () => {
    it('should successfully generate a new playlist from start to finish', async () => {
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      const { name, description } = TEST_DATA.playlists.new;
      const artistsToSelect = [TEST_DATA.artists.single.name];

      await actions.completeFirstStepNewPlaylist(name, description);
      await actions.completeSecondStep(artistsToSelect);

      expect(
        screen.getByRole('heading', {
          name: /steps.step3.playlistGeneratedSuccessfully/i,
        })
      ).toBeInTheDocument();
      const embeddedPlaylist = screen.getByTitle('Spotify embedded playlist');
      expect(embeddedPlaylist).toHaveAttribute(
        'src',
        `https://open.spotify.com/embed/playlist/${TEST_DATA.createdPlaylistId}`
      );

      expect(
        mockServices.playlistsService.createNewPlaylist
      ).toHaveBeenCalledWith({
        playlist: {
          name,
          description,
          isPublic: false,
        },
        artists: artistsToSelect.map((name) => ({ name })),
      });
    });

    it('should handle multiple artist selection and removal', async () => {
      vi.mocked(mockServices.artistsService.searchArtists).mockResolvedValue({
        artists: TEST_DATA.artists.multiple,
        message: 'Success',
      });

      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);
      await actions.completeFirstStepNewPlaylist();

      const [artist1, artist2] = TEST_DATA.artists.multiple.map((a) => a.name);
      await actions.selectArtistAndAssertSelected(artist1);
      await actions.selectArtistAndAssertSelected(artist2);

      expect(screen.getByText(artist1)).toBeInTheDocument();
      expect(screen.getByText(artist2)).toBeInTheDocument();

      const removeButton = screen.getByLabelText(
        `steps.step2.removeArtist ${artist1}`
      );
      await user.click(removeButton);
      expect(screen.queryByText(artist1)).not.toBeInTheDocument();
      expect(screen.getByText(artist2)).toBeInTheDocument();
    });

    it('should validate playlist name is required', async () => {
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      await actions.selectRadio(/steps.step1.form.createNewPlaylist.title/i);
      await actions.click(/steps.navigation.next/i);

      expect(
        await screen.findByText(/steps.errors.name.required/i)
      ).toBeInTheDocument();
    });
  });

  describe('Existing Playlist Flow', () => {
    it('should successfully update an existing playlist', async () => {
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      await actions.completeFirstStepExistingPlaylist();
      await actions.completeSecondStep([TEST_DATA.artists.single.name]);

      expect(
        screen.getByText(/steps.step3.playlistGeneratedSuccessfully/i)
      ).toBeInTheDocument();
      const embeddedPlaylist = screen.getByTitle('Spotify embedded playlist');
      expect(embeddedPlaylist).toHaveAttribute(
        'src',
        'https://open.spotify.com/embed/playlist/existing-playlist-1'
      );
    });

    it('should validate playlist selection is required', async () => {
      renderWithProviders(<GeneratePlaylistPage {...staticTranslations} />);

      await actions.selectRadio(/steps.step1.form.useExistingPlaylist.title/i);
      await actions.click(/steps.navigation.next/i);

      expect(
        await screen.findByText(/steps.errors.playlistSelected.required/i)
      ).toBeInTheDocument();
    });
  });
});
